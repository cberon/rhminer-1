/**
 *
 * Copyright 2018 Polyminer1 <https://github.com/polyminer1>
 *
 * To the extent possible under law, the author(s) have dedicated all copyright
 * and related and neighboring rights to this software to the public domain
 * worldwide. This software is distributed without any warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication along with
 * this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

///
/// @file
/// @copyright Polyminer1, QualiaLibre

#include "RandomHash_core.h"

const uint32_t Ghost_HashSize = (8*4);
struct GostHashCtx
{
    U32 sum[8];
    U32 hash[8];
    U32 len[8];
    unsigned char partial[32];
    size_t partial_bytes;
};

U32 gost_sbox_1[256] = { 
 466944, 
 479232,  477184,  462848,  485376,  475136,  458752,  487424,  471040,  481280,  460800,  483328,  473088,  489472,  468992,  464896,  368640,  380928,  378880,  364544,  387072,  376832,  360448,  389120,  372736,  382976,  362496,  385024,  374784,  391168,  370688, 
 366592,  139264,  151552,  149504,  135168,  157696,  147456,  131072,  159744,  143360,  153600,  133120,  155648,  145408,  161792,  141312,  137216,  401408,  413696,  411648,  397312,  419840,  409600,  393216,  421888,  405504,  415744,  395264,  417792,  407552, 
 423936,  403456,  399360,  204800,  217088,  215040,  200704,  223232,  212992,  196608,  225280,  208896,  219136,  198656,  221184,  210944,  227328,  206848,  202752,  434176,  446464,  444416,  430080,  452608,  442368,  425984,  454656,  438272,  448512,  428032, 
 450560,  440320,  456704,  436224,  432128,  499712,  512000,  509952,  495616,  518144,  507904,  491520,  520192,  503808,  514048,  493568,  516096,  505856,  522240,  501760,  497664,  335872,  348160,  346112,  331776,  354304,  344064,  327680,  356352,  339968, 
 350208,  329728,  352256,  342016,  358400,  337920,  333824,  73728,  86016,  83968,  69632,  92160,  81920,  65536,  94208,  77824,  88064,  67584,  90112,  79872,  96256,  75776,  71680,  106496,  118784,  116736,  102400,  124928,  114688,  98304, 
 126976,  110592,  120832,  100352,  122880,  112640,  129024,  108544,  104448,  270336,  282624,  280576,  266240,  288768,  278528,  262144,  290816,  274432,  284672,  264192,  286720,  276480,  292864,  272384,  268288,  40960,  53248,  51200,  36864,  59392, 
 49152,  32768,  61440,  45056,  55296,  34816,  57344,  47104,  63488,  43008,  38912,  8192,  20480,  18432,  4096,  26624,  16384,  0,  28672,  12288,  22528,  2048,  24576,  14336,  30720,  10240,  6144,  237568,  249856,  247808, 
 233472,  256000,  245760,  229376,  258048,  241664,  251904,  231424,  253952,  243712,  260096,  239616,  235520,  172032,  184320,  182272,  167936,  190464,  180224,  163840,  192512,  176128,  186368,  165888,  188416,  178176,  194560,  174080,  169984,  303104, 
 315392,  313344,  299008,  321536,  311296,  294912,  323584,  307200,  317440,  296960,  319488,  309248,  325632,  305152,  301056, };
U32 gost_sbox_2[256] = { 
 61341696, 
 62914560,  59244544,  65536000,  63963136,  60293120,  60817408,  59768832,  66060288,  66584576,  65011712,  62390272,  61865984,  58720256,  63438848,  64487424,  111673344,  113246208,  109576192,  115867648,  114294784,  110624768,  111149056,  110100480,  116391936,  116916224,  115343360,  112721920,  112197632,  109051904,  113770496, 
 114819072,  86507520,  88080384,  84410368,  90701824,  89128960,  85458944,  85983232,  84934656,  91226112,  91750400,  90177536,  87556096,  87031808,  83886080,  88604672,  89653248,  11010048,  12582912,  8912896,  15204352,  13631488,  9961472,  10485760,  9437184,  15728640,  16252928,  14680064,  12058624,  11534336, 
 8388608,  13107200,  14155776,  2621440,  4194304,  524288,  6815744,  5242880,  1572864,  2097152,  1048576,  7340032,  7864320,  6291456,  3670016,  3145728,  0,  4718592,  5767168,  69730304,  71303168,  67633152,  73924608,  72351744,  68681728,  69206016,  68157440,  74448896,  74973184,  73400320, 
 70778880,  70254592,  67108864,  71827456,  72876032,  78118912,  79691776,  76021760,  82313216,  80740352,  77070336,  77594624,  76546048,  82837504,  83361792,  81788928,  79167488,  78643200,  75497472,  80216064,  81264640,  128450560,  130023424,  126353408,  132644864,  131072000,  127401984,  127926272,  126877696,  133169152, 
 133693440,  132120576,  129499136,  128974848,  125829120,  130547712,  131596288,  120061952,  121634816,  117964800,  124256256,  122683392,  119013376,  119537664,  118489088,  124780544,  125304832,  123731968,  121110528,  120586240,  117440512,  122159104,  123207680,  36175872,  37748736,  34078720,  40370176,  38797312,  35127296,  35651584, 
 34603008,  40894464,  41418752,  39845888,  37224448,  36700160,  33554432,  38273024,  39321600,  52953088,  54525952,  50855936,  57147392,  55574528,  51904512,  52428800,  51380224,  57671680,  58195968,  56623104,  54001664,  53477376,  50331648,  55050240,  56098816,  103284736,  104857600,  101187584,  107479040,  105906176, 
 102236160,  102760448,  101711872,  108003328,  108527616,  106954752,  104333312,  103809024,  100663296,  105381888,  106430464,  94896128,  96468992,  92798976,  99090432,  97517568,  93847552,  94371840,  93323264,  99614720,  100139008,  98566144,  95944704,  95420416,  92274688,  96993280,  98041856,  19398656,  20971520,  17301504, 
 23592960,  22020096,  18350080,  18874368,  17825792,  24117248,  24641536,  23068672,  20447232,  19922944,  16777216,  21495808,  22544384,  44564480,  46137344,  42467328,  48758784,  47185920,  43515904,  44040192,  42991616,  49283072,  49807360,  48234496,  45613056,  45088768,  41943040,  46661632,  47710208,  27787264, 
 29360128,  25690112,  31981568,  30408704,  26738688,  27262976,  26214400,  32505856,  33030144,  31457280,  28835840,  28311552,  25165824,  29884416,  30932992, };
U32 gost_sbox_3[256] = { 
 805306370, 
 1610612738,  939524098,  134217730,  671088642,  2013265922,  1744830466,  1073741826,  536870914,  1342177282,  1207959554,  1879048194,  2,  402653186,  1476395010,  268435458,  2952790021,  3758096389,  3087007749,  2281701381,  2818572293,  4160749573,  3892314117,  3221225477,  2684354565,  3489660933,  3355443205,  4026531845,  2147483653,  2550136837,  3623878661, 
 2415919109,  805306373,  1610612741,  939524101,  134217733,  671088645,  2013265925,  1744830469,  1073741829,  536870917,  1342177285,  1207959557,  1879048197,  5,  402653189,  1476395013,  268435461,  805306368,  1610612736,  939524096,  134217728,  671088640,  2013265920,  1744830464,  1073741824,  536870912,  1342177280,  1207959552,  1879048192,  0, 
 402653184,  1476395008,  268435456,  2952790019,  3758096387,  3087007747,  2281701379,  2818572291,  4160749571,  3892314115,  3221225475,  2684354563,  3489660931,  3355443203,  4026531843,  2147483651,  2550136835,  3623878659,  2415919107,  805306369,  1610612737,  939524097,  134217729,  671088641,  2013265921,  1744830465,  1073741825,  536870913,  1342177281,  1207959553, 
 1879048193,  1,  402653185,  1476395009,  268435457,  2952790016,  3758096384,  3087007744,  2281701376,  2818572288,  4160749568,  3892314112,  3221225472,  2684354560,  3489660928,  3355443200,  4026531840,  2147483648,  2550136832,  3623878656,  2415919104,  2952790022,  3758096390,  3087007750,  2281701382,  2818572294,  4160749574,  3892314118,  3221225478,  2684354566, 
 3489660934,  3355443206,  4026531846,  2147483654,  2550136838,  3623878662,  2415919110,  2952790017,  3758096385,  3087007745,  2281701377,  2818572289,  4160749569,  3892314113,  3221225473,  2684354561,  3489660929,  3355443201,  4026531841,  2147483649,  2550136833,  3623878657,  2415919105,  805306371,  1610612739,  939524099,  134217731,  671088643,  2013265923,  1744830467, 
 1073741827,  536870915,  1342177283,  1207959555,  1879048195,  3,  402653187,  1476395011,  268435459,  805306372,  1610612740,  939524100,  134217732,  671088644,  2013265924,  1744830468,  1073741828,  536870916,  1342177284,  1207959556,  1879048196,  4,  402653188,  1476395012,  268435460,  2952790018,  3758096386,  3087007746,  2281701378,  2818572290, 
 4160749570,  3892314114,  3221225474,  2684354562,  3489660930,  3355443202,  4026531842,  2147483650,  2550136834,  3623878658,  2415919106,  2952790020,  3758096388,  3087007748,  2281701380,  2818572292,  4160749572,  3892314116,  3221225476,  2684354564,  3489660932,  3355443204,  4026531844,  2147483652,  2550136836,  3623878660,  2415919108,  805306374,  1610612742,  939524102, 
 134217734,  671088646,  2013265926,  1744830470,  1073741830,  536870918,  1342177286,  1207959558,  1879048198,  6,  402653190,  1476395014,  268435462,  2952790023,  3758096391,  3087007751,  2281701383,  2818572295,  4160749575,  3892314119,  3221225479,  2684354567,  3489660935,  3355443207,  4026531847,  2147483655,  2550136839,  3623878663,  2415919111,  805306375, 
 1610612743,  939524103,  134217735,  671088647,  2013265927,  1744830471,  1073741831,  536870919,  1342177287,  1207959559,  1879048199,  7,  402653191,  1476395015,  268435463, };
U32 gost_sbox_4[256] = { 
 232, 
 216,  160,  136,  152,  248,  168,  200,  128,  208,  240,  184,  176,  192,  144,  224,  2024,  2008,  1952,  1928,  1944,  2040,  1960,  1992,  1920,  2000,  2032,  1976,  1968,  1984,  1936, 
 2016,  1768,  1752,  1696,  1672,  1688,  1784,  1704,  1736,  1664,  1744,  1776,  1720,  1712,  1728,  1680,  1760,  104,  88,  32,  8,  24,  120,  40,  72,  0,  80,  112,  56,  48, 
 64,  16,  96,  744,  728,  672,  648,  664,  760,  680,  712,  640,  720,  752,  696,  688,  704,  656,  736,  1000,  984,  928,  904,  920,  1016,  936,  968,  896,  976,  1008, 
 952,  944,  960,  912,  992,  1384,  1368,  1312,  1288,  1304,  1400,  1320,  1352,  1280,  1360,  1392,  1336,  1328,  1344,  1296,  1376,  616,  600,  544,  520,  536,  632,  552,  584,  512, 
 592,  624,  568,  560,  576,  528,  608,  1256,  1240,  1184,  1160,  1176,  1272,  1192,  1224,  1152,  1232,  1264,  1208,  1200,  1216,  1168,  1248,  360,  344,  288,  264,  280,  376,  296, 
 328,  256,  336,  368,  312,  304,  320,  272,  352,  488,  472,  416,  392,  408,  504,  424,  456,  384,  464,  496,  440,  432,  448,  400,  480,  1896,  1880,  1824,  1800,  1816, 
 1912,  1832,  1864,  1792,  1872,  1904,  1848,  1840,  1856,  1808,  1888,  872,  856,  800,  776,  792,  888,  808,  840,  768,  848,  880,  824,  816,  832,  784,  864,  1512,  1496,  1440, 
 1416,  1432,  1528,  1448,  1480,  1408,  1488,  1520,  1464,  1456,  1472,  1424,  1504,  1128,  1112,  1056,  1032,  1048,  1144,  1064,  1096,  1024,  1104,  1136,  1080,  1072,  1088,  1040,  1120,  1640, 
 1624,  1568,  1544,  1560,  1656,  1576,  1608,  1536,  1616,  1648,  1592,  1584,  1600,  1552,  1632, };

/*
 *  A macro that performs a full encryption round of GOST 28147-89.
 *  Temporary variable t assumed and variables r and l for left and right
 *  blocks
 */

#define GOST_ENCRYPT_ROUND(k1, k2) \
t = (k1) + r; \
l ^= gost_sbox_1[t & 0xff] ^ gost_sbox_2[(t >> 8) & 0xff] ^ \
gost_sbox_3[(t >> 16) & 0xff] ^ gost_sbox_4[t >> 24]; \
t = (k2) + l; \
r ^= gost_sbox_1[t & 0xff] ^ gost_sbox_2[(t >> 8) & 0xff] ^ \
gost_sbox_3[(t >> 16) & 0xff] ^ gost_sbox_4[t >> 24]; \

 /* encrypt a block with the given key */

#define GOST_ENCRYPT(key) \
GOST_ENCRYPT_ROUND(key[0], key[1]) \
GOST_ENCRYPT_ROUND(key[2], key[3]) \
GOST_ENCRYPT_ROUND(key[4], key[5]) \
GOST_ENCRYPT_ROUND(key[6], key[7]) \
GOST_ENCRYPT_ROUND(key[0], key[1]) \
GOST_ENCRYPT_ROUND(key[2], key[3]) \
GOST_ENCRYPT_ROUND(key[4], key[5]) \
GOST_ENCRYPT_ROUND(key[6], key[7]) \
GOST_ENCRYPT_ROUND(key[0], key[1]) \
GOST_ENCRYPT_ROUND(key[2], key[3]) \
GOST_ENCRYPT_ROUND(key[4], key[5]) \
GOST_ENCRYPT_ROUND(key[6], key[7]) \
GOST_ENCRYPT_ROUND(key[7], key[6]) \
GOST_ENCRYPT_ROUND(key[5], key[4]) \
GOST_ENCRYPT_ROUND(key[3], key[2]) \
GOST_ENCRYPT_ROUND(key[1], key[0]) \
t = r; \
r = l; \
l = t;

/*
 *  "chi" compression function. the result is stored over h
 */

void gosthash_compress(U32 *h, U32 *m)
{
    int i;
    U32 l, r, t, key[8], u[8], v[8], w[8], s[8];

    static_assert (sizeof(U32) >= sizeof(U32), "BadHeader");

    memcpy(u, h, sizeof(u));
    memcpy(v, m, sizeof(u));

    for (i = 0; i < 8; i += 2)
    {
        w[0] = u[0] ^ v[0];	       /* w = u xor v */
        w[1] = u[1] ^ v[1];
        w[2] = u[2] ^ v[2];
        w[3] = u[3] ^ v[3];
        w[4] = u[4] ^ v[4];
        w[5] = u[5] ^ v[5];
        w[6] = u[6] ^ v[6];
        w[7] = u[7] ^ v[7];

        /* P-Transformation */

        key[0] = (w[0] & 0x000000ff) | ((w[2] & 0x000000ff) << 8) |
            ((w[4] & 0x000000ff) << 16) | ((w[6] & 0x000000ff) << 24);
        key[1] = ((w[0] & 0x0000ff00) >> 8) | (w[2] & 0x0000ff00) |
            ((w[4] & 0x0000ff00) << 8) | ((w[6] & 0x0000ff00) << 16);
        key[2] = ((w[0] & 0x00ff0000) >> 16) | ((w[2] & 0x00ff0000) >> 8) |
            (w[4] & 0x00ff0000) | ((w[6] & 0x00ff0000) << 8);
        key[3] = ((w[0] & 0xff000000) >> 24) | ((w[2] & 0xff000000) >> 16) |
            ((w[4] & 0xff000000) >> 8) | (w[6] & 0xff000000);
        key[4] = (w[1] & 0x000000ff) | ((w[3] & 0x000000ff) << 8) |
            ((w[5] & 0x000000ff) << 16) | ((w[7] & 0x000000ff) << 24);
        key[5] = ((w[1] & 0x0000ff00) >> 8) | (w[3] & 0x0000ff00) |
            ((w[5] & 0x0000ff00) << 8) | ((w[7] & 0x0000ff00) << 16);
        key[6] = ((w[1] & 0x00ff0000) >> 16) | ((w[3] & 0x00ff0000) >> 8) |
            (w[5] & 0x00ff0000) | ((w[7] & 0x00ff0000) << 8);
        key[7] = ((w[1] & 0xff000000) >> 24) | ((w[3] & 0xff000000) >> 16) |
            ((w[5] & 0xff000000) >> 8) | (w[7] & 0xff000000);

        r = h[i];			       /* encriphering transformation */
        l = h[i + 1];
        GOST_ENCRYPT(key);

        s[i] = r;
        s[i + 1] = l;

        if (i == 6)
            break;

        l = u[0] ^ u[2];		       /* U = A(U) */
        r = u[1] ^ u[3];
        u[0] = u[2];
        u[1] = u[3];
        u[2] = u[4];
        u[3] = u[5];
        u[4] = u[6];
        u[5] = u[7];
        u[6] = l;
        u[7] = r;

        if (i == 2)		       /* Constant C_3 */
        {
            u[0] ^= 0xff00ff00;
            u[1] ^= 0xff00ff00;
            u[2] ^= 0x00ff00ff;
            u[3] ^= 0x00ff00ff;
            u[4] ^= 0x00ffff00;
            u[5] ^= 0xff0000ff;
            u[6] ^= 0x000000ff;
            u[7] ^= 0xff00ffff;
        }

        l = v[0];			       /* V = A(A(V)) */
        r = v[2];
        v[0] = v[4];
        v[2] = v[6];
        v[4] = l ^ r;
        v[6] = v[0] ^ r;
        l = v[1];
        r = v[3];
        v[1] = v[5];
        v[3] = v[7];
        v[5] = l ^ r;
        v[7] = v[1] ^ r;
    }

    /* 12 rounds of the LFSR (computed from a product matrix) and xor in M */

    u[0] = m[0] ^ s[6];
    u[1] = m[1] ^ s[7];
    u[2] = m[2] ^ (s[0] << 16) ^ (s[0] >> 16) ^ (s[0] & 0xffff) ^
        (s[1] & 0xffff) ^ (s[1] >> 16) ^ (s[2] << 16) ^ s[6] ^ (s[6] << 16) ^
        (s[7] & 0xffff0000) ^ (s[7] >> 16);
    u[3] = m[3] ^ (s[0] & 0xffff) ^ (s[0] << 16) ^ (s[1] & 0xffff) ^
        (s[1] << 16) ^ (s[1] >> 16) ^ (s[2] << 16) ^ (s[2] >> 16) ^
        (s[3] << 16) ^ s[6] ^ (s[6] << 16) ^ (s[6] >> 16) ^ (s[7] & 0xffff) ^
        (s[7] << 16) ^ (s[7] >> 16);
    u[4] = m[4] ^
        (s[0] & 0xffff0000) ^ (s[0] << 16) ^ (s[0] >> 16) ^
        (s[1] & 0xffff0000) ^ (s[1] >> 16) ^ (s[2] << 16) ^ (s[2] >> 16) ^
        (s[3] << 16) ^ (s[3] >> 16) ^ (s[4] << 16) ^ (s[6] << 16) ^
        (s[6] >> 16) ^ (s[7] & 0xffff) ^ (s[7] << 16) ^ (s[7] >> 16);
    u[5] = m[5] ^ (s[0] << 16) ^ (s[0] >> 16) ^ (s[0] & 0xffff0000) ^
        (s[1] & 0xffff) ^ s[2] ^ (s[2] >> 16) ^ (s[3] << 16) ^ (s[3] >> 16) ^
        (s[4] << 16) ^ (s[4] >> 16) ^ (s[5] << 16) ^ (s[6] << 16) ^
        (s[6] >> 16) ^ (s[7] & 0xffff0000) ^ (s[7] << 16) ^ (s[7] >> 16);
    u[6] = m[6] ^ s[0] ^ (s[1] >> 16) ^ (s[2] << 16) ^ s[3] ^ (s[3] >> 16) ^
        (s[4] << 16) ^ (s[4] >> 16) ^ (s[5] << 16) ^ (s[5] >> 16) ^ s[6] ^
        (s[6] << 16) ^ (s[6] >> 16) ^ (s[7] << 16);
    u[7] = m[7] ^ (s[0] & 0xffff0000) ^ (s[0] << 16) ^ (s[1] & 0xffff) ^
        (s[1] << 16) ^ (s[2] >> 16) ^ (s[3] << 16) ^ s[4] ^ (s[4] >> 16) ^
        (s[5] << 16) ^ (s[5] >> 16) ^ (s[6] >> 16) ^ (s[7] & 0xffff) ^
        (s[7] << 16) ^ (s[7] >> 16);

    /* 16 * 1 round of the LFSR and xor in H */

    v[0] = h[0] ^ (u[1] << 16) ^ (u[0] >> 16);
    v[1] = h[1] ^ (u[2] << 16) ^ (u[1] >> 16);
    v[2] = h[2] ^ (u[3] << 16) ^ (u[2] >> 16);
    v[3] = h[3] ^ (u[4] << 16) ^ (u[3] >> 16);
    v[4] = h[4] ^ (u[5] << 16) ^ (u[4] >> 16);
    v[5] = h[5] ^ (u[6] << 16) ^ (u[5] >> 16);
    v[6] = h[6] ^ (u[7] << 16) ^ (u[6] >> 16);
    v[7] = h[7] ^ (u[0] & 0xffff0000) ^ (u[0] << 16) ^ (u[7] >> 16) ^
        (u[1] & 0xffff0000) ^ (u[1] << 16) ^ (u[6] << 16) ^ (u[7] & 0xffff0000);

    /* 61 rounds of LFSR, mixing up h (computed from a product matrix) */

    h[0] = (v[0] & 0xffff0000) ^ (v[0] << 16) ^ (v[0] >> 16) ^ (v[1] >> 16) ^
        (v[1] & 0xffff0000) ^ (v[2] << 16) ^ (v[3] >> 16) ^ (v[4] << 16) ^
        (v[5] >> 16) ^ v[5] ^ (v[6] >> 16) ^ (v[7] << 16) ^ (v[7] >> 16) ^
        (v[7] & 0xffff);
    h[1] = (v[0] << 16) ^ (v[0] >> 16) ^ (v[0] & 0xffff0000) ^ (v[1] & 0xffff) ^
        v[2] ^ (v[2] >> 16) ^ (v[3] << 16) ^ (v[4] >> 16) ^ (v[5] << 16) ^
        (v[6] << 16) ^ v[6] ^ (v[7] & 0xffff0000) ^ (v[7] >> 16);
    h[2] = (v[0] & 0xffff) ^ (v[0] << 16) ^ (v[1] << 16) ^ (v[1] >> 16) ^
        (v[1] & 0xffff0000) ^ (v[2] << 16) ^ (v[3] >> 16) ^ v[3] ^ (v[4] << 16) ^
        (v[5] >> 16) ^ v[6] ^ (v[6] >> 16) ^ (v[7] & 0xffff) ^ (v[7] << 16) ^
        (v[7] >> 16);
    h[3] = (v[0] << 16) ^ (v[0] >> 16) ^ (v[0] & 0xffff0000) ^
        (v[1] & 0xffff0000) ^ (v[1] >> 16) ^ (v[2] << 16) ^ (v[2] >> 16) ^ v[2] ^
        (v[3] << 16) ^ (v[4] >> 16) ^ v[4] ^ (v[5] << 16) ^ (v[6] << 16) ^
        (v[7] & 0xffff) ^ (v[7] >> 16);
    h[4] = (v[0] >> 16) ^ (v[1] << 16) ^ v[1] ^ (v[2] >> 16) ^ v[2] ^
        (v[3] << 16) ^ (v[3] >> 16) ^ v[3] ^ (v[4] << 16) ^ (v[5] >> 16) ^
        v[5] ^ (v[6] << 16) ^ (v[6] >> 16) ^ (v[7] << 16);
    h[5] = (v[0] << 16) ^ (v[0] & 0xffff0000) ^ (v[1] << 16) ^ (v[1] >> 16) ^
        (v[1] & 0xffff0000) ^ (v[2] << 16) ^ v[2] ^ (v[3] >> 16) ^ v[3] ^
        (v[4] << 16) ^ (v[4] >> 16) ^ v[4] ^ (v[5] << 16) ^ (v[6] << 16) ^
        (v[6] >> 16) ^ v[6] ^ (v[7] << 16) ^ (v[7] >> 16) ^ (v[7] & 0xffff0000);
    h[6] = v[0] ^ v[2] ^ (v[2] >> 16) ^ v[3] ^ (v[3] << 16) ^ v[4] ^
        (v[4] >> 16) ^ (v[5] << 16) ^ (v[5] >> 16) ^ v[5] ^ (v[6] << 16) ^
        (v[6] >> 16) ^ v[6] ^ (v[7] << 16) ^ v[7];
    h[7] = v[0] ^ (v[0] >> 16) ^ (v[1] << 16) ^ (v[1] >> 16) ^ (v[2] << 16) ^
        (v[3] >> 16) ^ v[3] ^ (v[4] << 16) ^ v[4] ^ (v[5] >> 16) ^ v[5] ^
        (v[6] << 16) ^ (v[6] >> 16) ^ (v[7] << 16) ^ v[7];
}

/* Clear the state of the given context structure. */

void gosthash_reset(GostHashCtx *ctx)
{
    memset(ctx->sum, 0, 32);
    memset(ctx->hash, 0, 32);
    memset(ctx->len, 0, 32);
    memset(ctx->partial, 0, 32);
    ctx->partial_bytes = 0;
}

/* Mix in a 32-byte chunk ("stage 3") */

void gosthash_bytes(GostHashCtx *ctx, const unsigned char *buf, size_t bits)
{
    int i, j;
    U32 a, b, c, m[8];

    /* convert bytes to a long words and compute the sum */

    j = 0;
    c = 0;
    for (i = 0; i < 8; i++)
    {
        a = ((U32)buf[j]) |
            (((U32)buf[j + 1]) << 8) |
            (((U32)buf[j + 2]) << 16) |
            (((U32)buf[j + 3]) << 24);
        j += 4;
        m[i] = a;
        b = ctx->sum[i];
        c = a + c + ctx->sum[i];
        ctx->sum[i] = c;
        c = ((c < a) || (c < b)) ? 1 : 0;
    }

    /* compress */

    gosthash_compress(ctx->hash, m);

    /* a 64-bit counter should be sufficient */

    ctx->len[0] += bits;
    if (ctx->len[0] < bits)
        ctx->len[1]++;
}

/* Mix in len bytes of data for the given buffer. */

void gosthash_update(GostHashCtx *ctx, const unsigned char *buf, size_t len)
{
    size_t i, j;

    i = ctx->partial_bytes;
    j = 0;
    while (i < 32 && j < len)
        ctx->partial[i++] = buf[j++];

    if (i < 32)
    {
        ctx->partial_bytes = i;
        return;
    }
    gosthash_bytes(ctx, ctx->partial, 256);

    while ((j + 32) < len)
    {
        gosthash_bytes(ctx, &buf[j], 256);
        j += 32;
    }

    i = 0;
    while (j < len)
        ctx->partial[i++] = buf[j++];
    ctx->partial_bytes = i;
}


/* Compute and save the 32-byte digest. */

void gosthash_final(GostHashCtx *ctx, unsigned char *digest)
{
    int i, j;
    U32 a;

    /* adjust and mix in the last chunk */

    if (ctx->partial_bytes > 0)
    {
        memset(&ctx->partial[ctx->partial_bytes], 0, 32 - ctx->partial_bytes);
        gosthash_bytes(ctx, ctx->partial, ctx->partial_bytes << 3);
    }

    /* mix in the length and the sum */

    gosthash_compress(ctx->hash, ctx->len);
    gosthash_compress(ctx->hash, ctx->sum);

    /* convert the output to bytes */

    j = 0;
    for (i = 0; i < 8; i++)
    {
        a = ctx->hash[i];
        digest[j] = (unsigned char)a;
        digest[j + 1] = (unsigned char)(a >> 8);
        digest[j + 2] = (unsigned char)(a >> 16);
        digest[j + 3] = (unsigned char)(a >> 24);
        j += 4;
    }
}

void RandomHash_Ghost(RH_StridePtr roundInput, RH_StridePtr output)
{
    int32_t len = (int32_t)RH_STRIDE_GET_SIZE(roundInput);
    U8 *dataPtr = RH_STRIDE_GET_DATA8(roundInput);

    RH_ALIGN(128) GostHashCtx ctx;
    gosthash_reset(&ctx);
    gosthash_update(&ctx, dataPtr, len);
    gosthash_final(&ctx, dataPtr);


    RH_STRIDE_SET_SIZE(output, Ghost_HashSize);
    memcpy(RH_STRIDE_GET_DATA8(output), ctx.hash, Ghost_HashSize);

    
}
